package com.vydra.death.screen.modules.impl.exploit;

import com.vydra.death.screen.events.UpdateWalkingPlayerEvent;
import com.vydra.death.screen.modules.Category;
import com.vydra.death.screen.modules.Module;
import com.vydra.death.screen.modules.settings.types.BooleanSetting;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class HitboxDesync extends Module {

    private final double MAGIC_NUMBER = 0.20000996883537;

    public HitboxDesync() {
        super("HitboxDesync", Category.EXPLOITS);
    }



    private BooleanSetting onGroundCheck = new BooleanSetting.Builder()
            .withModule(this)
            .withName("OnGroundCheck")
            .withDefaultValue(true)
            .build();

    private BooleanSetting slowlyMovement = new BooleanSetting.Builder()
            .withModule(this)
            .withName("SlowlyMovement")
            .withDefaultValue(true)
            .build();

    private BooleanSetting autoDisable = new BooleanSetting.Builder()
            .withModule(this)
            .withName("AutoDisable")
            .withDefaultValue(true)
            .build();



    @SubscribeEvent
    public void onUpdate(UpdateWalkingPlayerEvent event) {

        if (onGroundCheck.isValue() && !mc.player.onGround) return;

        final EnumFacing facing = mc.player.getHorizontalFacing();
        final AxisAlignedBB bb = mc.player.getEntityBoundingBox();
        final Vec3d center = bb.getCenter();
        final Vec3d offset = new Vec3d(facing.getDirectionVec());
        final Vec3d fin = merge(new Vec3d(new BlockPos(center)).add(0.5, 0.0, 0.5).add(offset.scale(MAGIC_NUMBER)), facing);

        if (!slowlyMovement.isValue())
            mc.player.setPositionAndUpdate((fin.x == 0.0) ? mc.player.posX : fin.x, mc.player.posY, (fin.z == 0.0) ? mc.player.posZ : fin.z);
        else
            centerMotion((fin.x == 0.0) ? mc.player.posX : fin.x, mc.player.posY, (fin.z == 0.0) ? mc.player.posZ : fin.z);

        if (autoDisable.isValue())
            onDisable();
    }

    private Vec3d merge(final Vec3d a, final EnumFacing facing) {
        return new Vec3d(a.x * Math.abs(facing.getDirectionVec().getX()), a.y * Math.abs(facing.getDirectionVec().getY()), a.z * Math.abs(facing.getDirectionVec().getZ()));
    }

    private void centerMotion(double x, double y, double z) {

        double[] centerPos = {x, y, z};

        mc.player.motionX = (centerPos[0] - mc.player.posX) / 2;
        mc.player.motionZ = (centerPos[2] - mc.player.posZ) / 2;
    }

}
